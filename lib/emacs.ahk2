; MIT License
; Copyright (c) 2021 Kosaki Mezumona
#UseHook
#include "commands.ahk2"
#include "key.ahk2"

class EmacsSimulator
{
	static Instance[]
	{
		get
		{
			static instance := EmacsSimulator.New()
			return instance
		}
	}

	ToolTipVisibleDuration[]
	{
		get => this._toolTipVisibleDuration
		set => this._toolTipVisibleDuration = value
	}

	ChordWaitingDuration[]
	{
		get => this._chordWaitingDuration
		set => this._chordWaitingDuration = value
	}

	IgnoredWindowMatcher[]
	{
		get
		{
			if (!this._ignoredWindowMatcher)
			{
				this._ignoredWindowMatcher := WindowMatcher.New()
			}
			return this._ignoredWindowMatcher
		}
		set
		{
			this._ignoredWindowMatcher := value
		}
	}

	__New()
	{
		this._currentState := this.ResetState()
		this._lastPushTime := A_NowUTC
		this._toolTipVisibleDuration := 3
		this._chordWaitingDuration := 3
		this._ignoredWindowMatcher := ""
	}

	RegisterKeyBinds()
	{
		HotIf((*) => this.IsAbleToOverrideKeys())

		HandleInputKey := (key, *) => this.PushKey(key)
		IgnoreInputKey := (*) => {}

		VisitKeys(vk, keyname)
		{
			if (keyname == "")
			{
				HotKey("<^!+" . vk, IgnoreInputKey)
				HotKey("<^!" . vk, IgnoreInputKey)
				HotKey("<^+" . vk, IgnoreInputKey)
				HotKey("<^" . vk, IgnoreInputKey)
			}
			else if (keyname != "ALT" && keyname != "LALT" && keyname != "RALT")
			{
				HotKey("<^!+" . vk, HandleInputKey.Bind("C-M-S-" . keyname))
				HotKey("<^!" . vk, HandleInputKey.Bind("C-M-" . keyname))
				HotKey("<^+" . vk, HandleInputKey.Bind("C-S-" . keyname))
				HotKey("<^" . vk, HandleInputKey.Bind("C-" . keyname))
			}
		}
		VirtualKeyCodes.Visit(Func("VisitKeys"))

		HotKey("<^_", HandleInputKey.Bind("C-_"))
		HotKey("!v", HandleInputKey.Bind("M-v"))
		HotKey("!w", HandleInputKey.Bind("M-w"))
		HotKey("!x", HandleInputKey.Bind("M-x"))

		HotIf()
	}

	IsAbleToOverrideKeys() => !(this._ignoredWindowMatcher && this._ignoredWindowMatcher.MatchActive())

	ResetState()
	{
		this._keyHistory := ""
		this._chordWaiting := false
		this._currentState := this.NextState("Initial")
		return this._currentState
	}

	PushKey(keyname)
	{
		this.ClearToolTip(true)
		this._keyHistory .= keyname . " "
		this._currentState := this._currentState.Call(keyname)
		this._lastPushTime := A_NowUTC
	}

	NextState(stateName) => (keyname) => this.%stateName%(keyname)

	Fallback(keyname)
	{
		if (keyname == "C-g")
		{
			Commands.EndSelection()
			Commands.Unselect()
			return this.ResetState()
		}

		SoundPlay(A_WinDir . "\Media\Windows Background.wav")
		ToolTip("The followed key combination is not a command.`n" . this._keyHistory)
		this.RegisterToolTipCleaner(this._toolTipVisibleDuration)
		return this.ResetState()
	}

	Initial(keyname)
	{
		;
		; Move cursor
		;
		if (keyname == "C-f")
		{
			Commands.MoveRight()
			return this.ResetState()
		}

		if (keyname == "C-b")
		{
			Commands.MoveLeft()
			return this.ResetState()
		}

		if (keyname == "C-n")
		{
			Commands.MoveDown()
			return this.ResetState()
		}

		if (keyname == "C-p")
		{
			Commands.MoveUp()
			return this.ResetState()
		}

		if (keyname == "C-a")
		{
			Commands.MoveHead()
			return this.ResetState()
		}

		if (keyname == "C-e")
		{
			Commands.MoveTail()
			return this.ResetState()
		}

		if (keyname == "C-v")
		{
			Commands.MoveNextPage()
			return this.ResetState()
		}

		if (keyname == "M-v")
		{
			Commands.MovePrevPage()
			return this.ResetState()
		}

		;
		; newline
		;
		if (keyname == "C-j")
		{
			Commands.PushEnter()
			return this.ResetState()
		}

		;
		; Delete
		;
		if (keyname == "C-d")
		{
			Commands.DeleteBackward()
			return this.ResetState()
		}

		if (keyname == "C-h")
		{
			Commands.DeleteForward()
			return this.ResetState()
		}

		;
		; Clipboard
		;
		if (keyname == "M-w")
		{
			Commands.EndSelection()
			Commands.CopyClipBoard()
			return this.ResetState()
		}

		if (keyname == "C-w")
		{
			Commands.EndSelection()
			Commands.CutClipBoard()
			return this.ResetState()
		}

		if (keyname == "C-k")
		{
			Commands.Unselect()
			Commands.StartSelection()
			Commands.MoveTail()
			Commands.EndSelection()
			Commands.CutClipBoard()
			return this.ResetState()
		}

		if (keyname == "C-y")
		{
			Commands.PasteClipBoard()
			Commands.EndSelection()
			return this.ResetState()
		}

		;
		; Undo / Redo
		;
		if (keyname == "C-/")
		{
			Commands.Undo()
			return this.ResetState()
		}

		if (keyname == "C-M-/")
		{
			Commands.Redo()
			return this.ResetState()
		}

		; 
		; Region
		;
		if (keyname == "C-SPC")
		{
			Commands.Unselect()
			Commands.StartSelection()
			return this.ResetState()
		}

		;
		; Chords
		;
		if (keyname == "C-x")
		{
			this._chordWaiting := true
			this.RegisterChordCancellation(this._chordWaitingDuration)
			return this.NextState("HandleCx")
		}

		if (keyname == "M-x")
		{
			Commands.ShowCommandPallet((command) => this.ExecuteCommand(command))
			return this.ResetState()
		}

		return this.Fallback(keyname)
	}

	HandleCx(keyname)
	{
		;
		; Files
		;
		if (keyname == "C-s")
		{
			Commands.SaveFile()
			return this.ResetState()
		}

		if (keyname == "C-w")
		{
			Commands.SaveFileAs()
			return this.ResetState()
		}

		if (keyname == "C-f")
		{
			Commands.OpenFile()
			return this.ResetState()
		}

		;
		; Close
		;
		if (keyname == "C-k")
		{
			Commands.CloseTab()
			return this.ResetState()
		}

		if (keyname == "C-c")
		{
			Commands.CloseWindow()
			return this.ResetState()
		}

		return this.Fallback(keyname)
	}

	ExecuteCommand(command)
	{
		if (command == "undo")
		{
			Commands.Undo()
			return
		}
		if (command == "redo")
		{
			Commands.Undo()
			return
		}

		ToolTip("Unknown command: '" . command . "'")
		this.RegisterToolTipCleaner(this._toolTipVisibleDuration)
	}

	RegisterChordCancellation(interval)
	{
		CancelChord := () => this.CancelChord()
		SetTimer(CancelChord, -interval * 1000)
	}

	CancelChord()
	{
		elapsed := EmacsSimulator.GetElapsedSeconds(this._lastPushTime)
		if (!this._chordWaiting || elapsed < this._chordWaitingDuration)
		{
			this.RegisterChordCancellation(this._chordWaitingDuration - elapsed)
			return
		}
		
		ToolTip("'" . this._keyHistory . "' is timeout.")
		this.RegisterToolTipCleaner(this._toolTipVisibleDuration)
		this.ResetState()
	}

	RegisterToolTipCleaner(interval)
	{
		ClearToolTip := () => this.ClearToolTip(false)
		SetTimer(ClearToolTip, -interval * 1000)
	}

	ClearToolTip(forced := false)
	{
		elapsed := EmacsSimulator.GetElapsedSeconds(this._lastPushTime)
		if (!forced && elapsed < this._toolTipVisibleDuration)
		{
			return
		}
		ToolTip()
	}

	static GetElapsedSeconds(t)
	{
		return A_NowUTC - t
	}
}
